"use strict";exports.id=3567,exports.ids=[3567],exports.modules={83567:(a,b,c)=>{c.d(b,{C:()=>f});var d=c(30477),e=c(2995);e.Ik({sessionId:e.Yj().uuid(),status:e.k5(["initializing","active","paused","completed","failed","archived"]),createdAt:e.p6(),updatedAt:e.p6(),lastActivity:e.p6(),participantCount:e.ai(),messageCount:e.ai(),completedTasks:e.YO(e.Yj()),pendingTasks:e.YO(e.Yj()),sessionMetrics:e.Ik({averageResponseTime:e.ai(),totalInteractions:e.ai(),successfulHandoffs:e.ai(),failedHandoffs:e.ai()}),configuration:e.Ik({maxDuration:e.ai().optional(),autoArchiveAfter:e.ai().default(864e5),allowDynamicAgentJoining:e.zM().default(!0),maxParticipants:e.ai().default(10),requiresHumanApproval:e.zM().default(!1)})});class f{constructor(a,b){this.activeSessions=new Map,this.sessionStates=new Map,this.sessionCheckpoints=new Map,this.sessionTemplates=new Map,this.sessionCleanupInterval=null,this.collaborationHub=a,this.messageRouter=b,this.initializeDefaultTemplates(),"true"===process.env.ENABLE_SESSION_CLEANUP&&this.startSessionCleanup()}async createSession(a){try{let b,c=crypto.randomUUID();if(a.templateId&&!(b=this.sessionTemplates.get(a.templateId)))throw Error(`Session template ${a.templateId} not found`);let e=a.requiredAgents||b?.requiredAgents||[],f=e.filter(a=>{let b=this.collaborationHub.getAgent(a);return b&&b.currentSessions.length<b.maxConcurrentSessions});if(f.length<e.length){let a=e.filter(a=>!f.includes(a));throw Error(`Required agents not available: ${a.join(", ")}`)}let g=await this.collaborationHub.initiateCollaboration({userId:parseInt(a.userId,10)||0,requestType:"project",requiredAgents:f,projectName:a.goal,context:a.initialContext||{},priority:"medium"});if("error"===g.status)throw Error(g.message||"Failed to create collaboration session");let h=this.collaborationHub.getSession(g.sessionId);if(!h)throw Error("Session was created but could not be retrieved");let i={sessionId:h.id,status:"initializing",createdAt:new Date,updatedAt:new Date,lastActivity:new Date,participantCount:f.length,messageCount:0,completedTasks:[],pendingTasks:b?.workflow?.steps.map(a=>a.id)||[],sessionMetrics:{averageResponseTime:0,totalInteractions:0,successfulHandoffs:0,failedHandoffs:0},configuration:{autoArchiveAfter:864e5,allowDynamicAgentJoining:!0,maxParticipants:10,requiresHumanApproval:!1,...b?.configuration,...a.configuration}};return this.activeSessions.set(c,h),this.sessionStates.set(c,i),this.sessionCheckpoints.set(c,[]),await this.createCheckpoint(c,"Session initialized"),b?.initialPrompt&&await this.sendSystemMessage(c,b.initialPrompt,a.initialContext),i.status="active",i.updatedAt=new Date,this.sessionStates.set(c,i),(0,d.fH)(`âœ… Session ${c} created with ${f.length} agents`),h}catch(a){throw(0,d.vV)("Error creating session:",a),a}}async joinSession(a,b){try{let c=this.activeSessions.get(a),e=this.sessionStates.get(a);if(!c||!e)throw Error(`Session ${a} not found`);if("active"!==e.status)throw Error(`Cannot join session in ${e.status} status`);if(!e.configuration.allowDynamicAgentJoining)throw Error("Dynamic agent joining is disabled for this session");if(c.participatingAgents.length>=e.configuration.maxParticipants)throw Error("Session has reached maximum participant limit");let f=this.collaborationHub.getAgent(b);if(!f)throw Error(`Agent ${b} not found`);if(f.currentSessions.length>=f.maxConcurrentSessions)throw Error(`Agent ${b} is at maximum concurrent session limit`);if(c.participatingAgents.includes(b))return!0;return c.participatingAgents.push(b),f.currentSessions.push(a),e.participantCount=c.participatingAgents.length,e.updatedAt=new Date,e.lastActivity=new Date,this.sessionStates.set(a,e),await this.sendSystemMessage(a,`Agent ${f.name} has joined the collaboration session.`,{newAgent:{id:b,name:f.name,capabilities:f.capabilities}}),await this.createCheckpoint(a,`Agent ${b} joined`),(0,d.fH)(`âœ… Agent ${b} joined session ${a}`),!0}catch(a){return(0,d.vV)(`Error joining session: ${a}`),!1}}async leaveSession(a,b,c){try{let e=this.activeSessions.get(a),f=this.sessionStates.get(a);if(!e||!f)throw Error(`Session ${a} not found`);let g=e.participatingAgents.indexOf(b);if(-1===g)return!0;e.participatingAgents.splice(g,1);let h=this.collaborationHub.getAgent(b);if(h){let b=h.currentSessions.indexOf(a);-1!==b&&h.currentSessions.splice(b,1)}f.participantCount=e.participatingAgents.length,f.updatedAt=new Date,f.lastActivity=new Date,this.sessionStates.set(a,f);let i=h?.name||b;return await this.sendSystemMessage(a,`Agent ${i} has left the collaboration session.${c?` Reason: ${c}`:""}`,{leftAgent:{id:b,name:i,reason:c}}),await this.createCheckpoint(a,`Agent ${b} left: ${c||"No reason provided"}`),0===e.participatingAgents.length&&await this.pauseSession(a,"No participants remaining"),(0,d.fH)(`âœ… Agent ${b} left session ${a}`),!0}catch(a){return(0,d.vV)(`Error leaving session: ${a}`),!1}}async pauseSession(a,b){try{let c=this.sessionStates.get(a);if(!c)throw Error(`Session ${a} not found`);if("active"!==c.status)throw Error(`Cannot pause session in ${c.status} status`);return c.status="paused",c.updatedAt=new Date,this.sessionStates.set(a,c),await this.sendSystemMessage(a,`Session has been paused.${b?` Reason: ${b}`:""}`,{pauseReason:b}),await this.createCheckpoint(a,`Session paused: ${b||"Manual pause"}`),(0,d.fH)(`â¸ï¸ Session ${a} paused: ${b||"Manual pause"}`),!0}catch(a){return(0,d.vV)(`Error pausing session: ${a}`),!1}}async resumeSession(a){try{let b=this.sessionStates.get(a);if(!b)throw Error(`Session ${a} not found`);if("paused"!==b.status)throw Error(`Cannot resume session in ${b.status} status`);return b.status="active",b.updatedAt=new Date,b.lastActivity=new Date,this.sessionStates.set(a,b),await this.sendSystemMessage(a,"Session has been resumed. Collaboration can continue.",{}),await this.createCheckpoint(a,"Session resumed"),(0,d.fH)(`â–¶ï¸ Session ${a} resumed`),!0}catch(a){return(0,d.vV)(`Error resuming session: ${a}`),!1}}async completeSession(a,b){try{let c=this.activeSessions.get(a),e=this.sessionStates.get(a);if(!c||!e)throw Error(`Session ${a} not found`);if(!["active","paused"].includes(e.status))throw Error(`Cannot complete session in ${e.status} status`);for(let b of(e.status="completed",e.updatedAt=new Date,this.sessionStates.set(a,e),c.participatingAgents)){let c=this.collaborationHub.getAgent(b);if(c){let b=c.currentSessions.indexOf(a);-1!==b&&c.currentSessions.splice(b,1)}}return await this.sendSystemMessage(a,`Session completed successfully.${b?` Summary: ${b}`:""}`,{completionSummary:b}),await this.createCheckpoint(a,`Session completed: ${b||"No summary provided"}`),setTimeout(()=>{this.archiveSession(a).catch(console.error)},e.configuration.autoArchiveAfter),(0,d.fH)(`âœ… Session ${a} completed`),!0}catch(a){return(0,d.vV)(`Error completing session: ${a}`),!1}}async archiveSession(a){try{let b=this.sessionStates.get(a);if(!b)return!1;if("completed"!==b.status&&"failed"!==b.status)throw Error(`Cannot archive session in ${b.status} status`);return b.status="archived",b.updatedAt=new Date,this.sessionStates.set(a,b),await this.createCheckpoint(a,"Session archived"),(0,d.fH)(`ðŸ“¦ Session ${a} archived`),!0}catch(a){return(0,d.vV)(`Error archiving session: ${a}`),!1}}getSession(a){return this.activeSessions.get(a)||null}getSessionState(a){return this.sessionStates.get(a)||null}getActiveSessions(){return Array.from(this.activeSessions.values())}getUserSessions(a){let b=parseInt(a,10);return Array.from(this.activeSessions.values()).filter(a=>a.userId===b)}getAgentSessions(a){return Array.from(this.activeSessions.values()).filter(b=>b.participatingAgents.includes(a))}async createCheckpoint(a,b){try{let c=this.activeSessions.get(a),e=this.sessionStates.get(a);if(!c||!e)throw Error(`Session ${a} not found`);let f=crypto.randomUUID(),g={checkpointId:f,sessionId:a,timestamp:new Date,state:{...e},messageHistory:[],agentStates:{},userContext:c.metadata||{}},h=this.sessionCheckpoints.get(a)||[];return h.push(g),h.length>10&&h.splice(0,h.length-10),this.sessionCheckpoints.set(a,h),(0,d.fH)(`ðŸ“¸ Checkpoint created for session ${a}: ${b}`),f}catch(a){throw(0,d.vV)(`Error creating checkpoint: ${a}`),a}}async restoreFromCheckpoint(a,b){try{let c=this.sessionCheckpoints.get(a);if(!c)throw Error(`No checkpoints found for session ${a}`);let e=c.find(a=>a.checkpointId===b);if(!e)throw Error(`Checkpoint ${b} not found`);return this.sessionStates.set(a,{...e.state}),await this.sendSystemMessage(a,`Session restored from checkpoint created at ${e.timestamp.toISOString()}`,{restoredFromCheckpoint:b}),(0,d.fH)(`ðŸ”„ Session ${a} restored from checkpoint ${b}`),!0}catch(a){return(0,d.vV)(`Error restoring from checkpoint: ${a}`),!1}}async updateTaskStatus(a,b,c){try{let e=this.sessionStates.get(a);if(!e)throw Error(`Session ${a} not found`);if("completed"===c){let a=e.pendingTasks.indexOf(b);-1!==a&&e.pendingTasks.splice(a,1),e.completedTasks.includes(b)||e.completedTasks.push(b)}else{let a=e.completedTasks.indexOf(b);-1!==a&&e.completedTasks.splice(a,1),e.pendingTasks.includes(b)||e.pendingTasks.push(b)}return e.updatedAt=new Date,this.sessionStates.set(a,e),(0,d.fH)(`ðŸ“ Task ${b} marked as ${c} in session ${a}`),!0}catch(a){return(0,d.vV)(`Error updating task status: ${a}`),!1}}async sendSystemMessage(a,b,c){let d={id:crypto.randomUUID(),sessionId:a,fromAgent:"system",toAgent:null,messageType:"notification",content:b,timestamp:new Date,priority:"medium",metadata:c};await this.messageRouter.broadcastMessage(d)}initializeDefaultTemplates(){let a=[{id:"general-collaboration",name:"General Collaboration",description:"Multi-purpose collaboration session for various tasks",requiredAgents:["assistant","researcher"],optionalAgents:["analyst","creative"],configuration:{maxDuration:72e5,autoArchiveAfter:864e5,allowDynamicAgentJoining:!0,maxParticipants:5,requiresHumanApproval:!1}},{id:"research-project",name:"Research Project",description:"Structured research collaboration with defined workflow",requiredAgents:["researcher","analyst"],optionalAgents:["assistant"],initialPrompt:"Welcome to the research collaboration session. Please begin by defining the research objectives and methodology.",configuration:{maxDuration:144e5,autoArchiveAfter:1728e5,allowDynamicAgentJoining:!0,maxParticipants:4,requiresHumanApproval:!1},workflow:{steps:[{id:"define-objectives",name:"Define Research Objectives",assignedAgent:"researcher"},{id:"collect-data",name:"Collect and Analyze Data",assignedAgent:"analyst"},{id:"synthesize-findings",name:"Synthesize Findings",dependencies:["collect-data"]},{id:"prepare-report",name:"Prepare Final Report",dependencies:["synthesize-findings"]}]}},{id:"creative-brainstorm",name:"Creative Brainstorming",description:"Creative ideation and brainstorming session",requiredAgents:["creative","assistant"],optionalAgents:["analyst"],initialPrompt:"Let's begin a creative brainstorming session. Please share your initial ideas and build upon each other's contributions.",configuration:{maxDuration:36e5,autoArchiveAfter:864e5,allowDynamicAgentJoining:!0,maxParticipants:6,requiresHumanApproval:!1}}];a.forEach(a=>{this.sessionTemplates.set(a.id,a)}),(0,d.fH)(`âœ… Session Manager initialized with ${a.length} default templates`)}startSessionCleanup(){this.sessionCleanupInterval=setInterval(()=>{this.cleanupInactiveSessions()},3e5)}cleanupInactiveSessions(){let a=Date.now(),b=[];for(let[c,d]of this.sessionStates.entries()){let e=a-d.lastActivity.getTime(),f=d.configuration.maxDuration;(f&&e>f||"completed"===d.status&&e>d.configuration.autoArchiveAfter)&&b.push(c)}b.forEach(a=>{this.archiveSession(a).catch(console.error)}),b.length>0&&(0,d.fH)(`ðŸ§¹ Cleaned up ${b.length} inactive sessions`)}getSessionTemplates(){return Array.from(this.sessionTemplates.values())}addSessionTemplate(a){this.sessionTemplates.set(a.id,a)}removeSessionTemplate(a){return this.sessionTemplates.delete(a)}destroy(){this.sessionCleanupInterval&&(clearInterval(this.sessionCleanupInterval),this.sessionCleanupInterval=null)}}}};